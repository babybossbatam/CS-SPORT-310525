} = useQuery<FixtureData[] | undefined, Error>({
    queryKey: ["myNewLeague2", "allFixtures", selectedDate],
    queryFn: async (): Promise<FixtureData[] | undefined> => {
      console.log(
        `ðŸŽ¯ [MyNewLeague2] Fetching fixtures for ${leagueIds.length} leagues on ${selectedDate}:`,
        leagueIds,
      );

      // First, get cached ended matches for all leagues
      const cachedEndedMatches: FixtureData[] = [];
      leagueIds.forEach((leagueId) => {
        const cached = getCachedEndedMatches(selectedDate, leagueId);
        cachedEndedMatches.push(...cached);
      });

      console.log(
        `ðŸ’¾ [MyNewLeague2] Retrieved ${cachedEndedMatches.length} cached ended matches`,
      );

      // Process leagues in optimized batches
      const batchSize = 5; // Increase concurrent requests for priority leagues
      const results: Array<{ leagueId: number; fixtures: FixtureData[]; error?: string; networkError?: boolean; rateLimited?: boolean; timeout?: boolean }> = [];

      for (let i = 0; i < leagueIds.length; i += batchSize) {
        const batch = leagueIds.slice(i, i + batchSize);
        console.log(
          `ðŸ”„ [MyNewLeague2] Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(leagueIds.length / batchSize)}: leagues ${batch.join(", ")}`,
        );

        const batchPromises = batch.map(async (leagueId, index) => {
          // Minimal delay only for large batches
          if (index > 2) {
            await delay(10); // Reduced to 10ms delay
          }

          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
              controller.abort("Request timeout after 10 seconds"); // Adjusted timeout
            }, 10000); // Adjusted to 10 seconds

            const response = await fetch(`/api/leagues/${leagueId}/fixtures`, {
              signal: controller.signal,
            }).catch((fetchError) => {
              clearTimeout(timeoutId);

              // Handle specific timeout errors
              if (
                fetchError.name === "AbortError" ||
                fetchError.message?.includes("aborted") ||
                fetchError.message?.includes("timeout")
              ) {
                console.warn(
                  `â° [MyNewLeague2] Request timeout for league ${leagueId}: Request exceeded 10 seconds - falling back to cached data`, // Adjusted log message
                );
                return null;
              }

              console.warn(
                `ðŸŒ [MyNewLeague2] Network error for league ${leagueId}: ${fetchError.message}`,
              );
              return null;
            });

            clearTimeout(timeoutId);

            if (!response) {
              return {
                leagueId,
                fixtures: [],
                error: "Request timeout or network error",
                networkError: true,
              };
            }

            if (!response.ok) {
              if (response.status === 429) {
                console.warn(
                  `âš ï¸ [MyNewLeague2] Rate limited for league ${leagueId}, will use cached data if available`,
                );
                return {
                  leagueId,
                  fixtures: [],
                  error: "Rate limited",
                  rateLimited: true,
                };
              }
              console.log(
                `âŒ [MyNewLeague2] Failed to fetch league ${leagueId}: ${response.status} ${response.statusText}`,
              );
              return {
                leagueId,
                fixtures: [],
                error: `HTTP ${response.status}`,
              };
            }

            const data = await response.json().catch((jsonError) => {
              console.warn(
                `ðŸ“„ [MyNewLeague2] JSON parse error for league ${leagueId}: ${jsonError.message}`,
              );
              return { response: [] };
            });

            const fixtures = data.response || data || [];

            // Cache ended matches for this league
            cacheEndedMatches(selectedDate, leagueId, fixtures);

            console.log(
              `âœ… [MyNewLeague2] League ${leagueId}: ${fixtures.length} fixtures`,
            );
            return { leagueId, fixtures, error: null };
          } catch (error) {
            const errorMessage =
              error instanceof Error ? error.message : "Unknown error";

            // Handle timeout errors specifically
            if (
              error instanceof Error &&
              (error.name === "AbortError" ||
                errorMessage.includes("abort") ||
                errorMessage.includes("timeout"))
            ) {
              console.log(
                `â° [MyNewLeague2] Timeout error for league ${leagueId}: Request exceeded 10 seconds - falling back to cached data`, // Adjusted log message
              );
              return {
                leagueId,
                fixtures: [],
                error: "Request timeout",
                networkError: true,
                timeout: true,
              };
            }

            console.warn(
              `âš ï¸ [MyNewLeague2] Error fetching league ${leagueId}: ${errorMessage}`,
            );
            return {
              leagueId,
              fixtures: [],
              error: errorMessage,
              networkError: true,
            };
          }
        });

        try {
          const batchResults = await Promise.allSettled(batchPromises);
          const processedResults = batchResults.map((result) =>
            result.status === "fulfilled"
              ? result.value
              : {
                  leagueId: 0, // Placeholder for leagueId if promise rejected
                  fixtures: [],
                  error: "Promise rejected",
                  networkError: true,
                },
          );
          results.push(...processedResults);
        } catch (batchError) {
          console.warn(
            `âš ï¸ [MyNewLeague2] Batch processing error: ${batchError}`,
          );
          // Continue with empty results for this batch
          results.push(
            ...batch.map((leagueId) => ({
              leagueId,
              fixtures: [],
              error: "Batch processing failed",
              networkError: true,
            })),
          );
        }

        // Add delay between batches to be more API-friendly
        if (i + batchSize < leagueIds.length) {
          console.log(`â³ [MyNewLeague2] Waiting 500ms before next batch...`);
          await delay(25);
        }
      }

      // Learn teams from fixtures before processing
      smartTeamTranslation.learnTeamsFromFixtures(
        results.flatMap((res) => res.fixtures),
      );

      // Combine fresh fixtures with cached ended matches
      const allFixturesMap = new Map<number, FixtureData>();

      // Add cached ended matches first
      cachedEndedMatches.forEach((fixture) => {
        if (fixture?.fixture?.id && !allFixturesMap.has(fixture.fixture.id)) {
          allFixturesMap.set(fixture.fixture.id, fixture);
        }
      });

      // Add fresh fixtures (this will overwrite cached ones if they exist in fresh data)
      results.forEach((result) => {
        result.fixtures.forEach((fixture: FixtureData) => {
          if (fixture?.fixture?.id) {
            // Only add if not cached or if it's not an old ended match
            if (
              !allFixturesMap.has(fixture.fixture.id) ||
              !isMatchOldEnded(fixture)
            ) {
              allFixturesMap.set(fixture.fixture.id, fixture);
            }
          }
        });
      });

      const finalFixtures = Array.from(allFixturesMap.values());

      // Log detailed results
      console.log(`ðŸ”„ [MyNewLeague2] Fetch results:`, {
        totalBatches: Math.ceil(leagueIds.length / batchSize),
        successfulFetches: results.filter((r) => !r.error && r.fixtures.length > 0).length,
        failedFetches: results.filter((r) => r.error).length,
        cachedEndedMatches: cachedEndedMatches.length,
        totalFixtures: finalFixtures.length,
        fixturesFetchedInBatches: results.reduce((sum, r) => sum + r.fixtures.length, 0),
        duplicatesRemoved:
          results.reduce((sum, r) => sum + r.fixtures.length, 0) +
          cachedEndedMatches.length -
          finalFixtures.length,
        leagueBreakdown: results.map((r) => ({
          league: r.leagueId,
          fixtures: r.fixtures.length,
          error: r.error,
          networkError: r.networkError,
          rateLimited: r.rateLimited,
          timeout: r.timeout,
        })),
      });

      return finalFixtures;
    },
    // Apply dynamic cache configuration
    ...dynamicCacheConfig,
    // Additional configuration for better UX
    retry: (failureCount: number, error: Error): boolean => {
      // Don't retry too aggressively for historical data (no refetchInterval)
      if (!dynamicCacheConfig.refetchInterval) return failureCount < 2;
      // For live data, allow more retries
      return failureCount < 3;
    },
    retryDelay: (attemptIndex: number): number => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
